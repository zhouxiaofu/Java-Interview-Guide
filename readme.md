# Java基础

## HashMap（Java8）

1. **结构优化**：在 Java 8 中，当一个 bucket（桶）中的元素过多时（默认超过 8 个），HashMap 会将这个 bucket 中的链表转换成红黑树，这大大提高了在高冲突情况下的查找效率。如果元素数量减少，红黑树又会退化成链表。
2. **Hash 函数**：HashMap 使用内部的 hash 函数来分配元素的存储位置。在 Java 8 中，hash 函数被改进以减少碰撞。
3. **并发改进**：尽管 `HashMap` 本身不是线程安全的，但在 Java 8 中，它的并发行为得到了一定的改善，特别是在扩容过程中。然而，对于需要高并发的应用，通常建议使用 `ConcurrentHashMap`。
4. **空间效率和性能**：Java 8 的 `HashMap` 实现在空间效率和性能方面都有所改进，特别是通过树化 bucket 和优化 hash 函数来减少碰撞。
5. **默认容量和加载因子**：默认的初始容量是 16，加载因子是 0.75。加载因子是一个衡量 HashMap 满的程度的指标，当 HashMap 的填充度超过加载因子时，将会进行扩容（即重哈希）。
6. **计算模式**：Java 8 引入了一些新的 API，如 `computeIfAbsent` 和 `computeIfPresent`，这些方法结合了检查、获取和计算的步骤，使得一些常见的模式变得更加简洁。



### 为什么bucket数量需要是2的次方？

1. **高效的索引计算**：当 bucket 数量是 2 的次方时，HashMap 可以通过位运算来计算一个对象的哈希值应该映射到哪个 bucket。位运算（如 `hash & (n-1)`，其中 `n` 是 bucket 数量）比模运算（如 `hash % n`）要快得多。位运算的效率在高负载的情况下尤其重要。
2. **均匀的数据分布**：使用 2 的次方作为 bucket 数量有助于哈希值在 buckets 之间分布得更均匀。这种均匀分布可以减少哈希碰撞，从而提高 HashMap 的整体性能。
3. **扩容时的数据迁移效率**：在 HashMap 扩容时（例如，当元素数量超过容量与加载因子的乘积），容量扩大到原来的两倍。由于容量始终是 2 的次方，所以在扩容过程中，元素的重新分布可以通过简单的位运算来完成，而不需要重新计算哈希值。这样可以大大提高扩容的效率。



##  AQS

1. **核心概念**：AQS 是一个提供了锁和其他同步机制的基础框架。它使用一个 int 类型的变量来表示同步状态，并通过一个 FIFO 队列来管理阻塞线程。
2. **同步状态**：AQS 使用一个内部的 volatile int 类型的变量来表示同步状态。子类可以通过改变这个状态来实现锁的获取和释放。
3. **节点和等待队列**：AQS 内部维护了一个等待队列，每个节点（Node）代表一个等待获取锁的线程。如果线程无法获取锁，则会被包装成节点加入到队列的尾部，并在必要时阻塞。
4. **获取和释放锁**：AQS 提供了方法来管理对同步状态的获取和释放。子类通过重写这些方法来实现具体的锁机制。
   - `tryAcquire`：尝试获取资源，成功则返回 true，失败则返回 false。
   - `tryRelease`：尝试释放资源，成功则返回 true，失败则返回 false。
5. **独占模式和共享模式**：AQS 支持两种同步模式。独占模式（如 ReentrantLock）一次只允许一个线程持有资源，而共享模式（如 Semaphore、CountDownLatch）则允许多个线程同时持有资源。
6. **公平性和非公平性**：AQS 可以支持创建公平锁和非公平锁。公平锁按照请求的顺序授予锁，而非公平锁则可能插队。
7. **重要的子类**：基于 AQS 实现的同步器包括 ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等。



## ReentrantLock和synchronized的区别

1. **基本锁机制和工作原理**：
   - **`synchronized`**：内置于 Java 语言中，提供了一种基于监视器模式的同步机制。它可以用于方法（实例方法和静态方法）和代码块上，且是隐式的，不需要手动加锁和释放锁。
   - **`ReentrantLock`**：是 Java.util.concurrent.locks 包的一部分，提供了一种高级的同步机制。它需要显式地创建锁对象，手动进行加锁和解锁。
2. **锁的公平性选项**：
   - **`synchronized`**：不支持公平性。不保证等待时间最长的线程会首先获取锁。
   - **`ReentrantLock`**：支持公平性和非公平性。可以在创建锁时指定，确保按照等待时间的顺序获取锁。
3. **灵活性和控制能力**：
   - **`synchronized`**：较少的控制能力。不能尝试非阻塞地获取锁，也不能中断一个正在等待获取锁的线程。
   - **`ReentrantLock`**：更高的灵活性。提供了尝试非阻塞地获取锁（`tryLock()`）、可中断的锁获取操作（`lockInterruptibly()`）以及支持条件变量（`Condition`）。
4. **对性能的影响**：
   - **`synchronized`**：在 JDK 1.6 之后，通过引入偏向锁和轻量级锁等机制，性能大幅提升，但在高竞争环境下可能仍然落后于 `ReentrantLock`。
   - **`ReentrantLock`**：在高度竞争的环境下，通常提供比 `synchronized` 更好的性能，但在低竞争环境下，性能差异不大。
5. **最佳使用场景**：
   - **`synchronized`**：适合简单的同步需求，以及锁竞争不是非常激烈的场景。因为其语法简洁，易于阅读和维护。
   - **`ReentrantLock`**：适合复杂的同步需求，或者需要更多同步控制，如公平锁、可中断锁、条件变量等。它提供了更大的灵活性，但需要更仔细的锁管理。



## 各种for循环的效率和使用场景

1. **传统的 `for` 循环（`for (int i = 0; ...)`）**：
   - **效率**：通常来说，在遍历数组时效率最高，因为它允许直接通过索引访问元素，减少了额外的方法调用。
   - **使用场景**：适用于需要访问数组索引或需要修改遍历过程中的计数器值的场景。
2. **`for-each` 循环**：
   - **效率**：
     - 当遍历集合时，`for-each` 循环是基于 `Iterator` 实现的。其效率通常与传统 `for` 循环相近，但在某些情况下（尤其是在遍历大型集合时）可能会略低于传统 `for` 循环，因为它涉及到 `Iterator` 对象的创建和方法调用的额外开销。
     - 当遍历数组时，`for-each` 循环是基于索引的循环，其效率与传统的基于索引的 `for` 循环相当。
   - **使用场景**：
     - `for-each` 循环适用于不需要直接索引访问，只需遍历集合或数组中的每个元素的场景。
     - 它提供了一种更简洁、更易读的遍历方式，特别是在代码的可读性和简洁性更为重要时。
3. **Stream API 的 `forEach`**：
   - **效率**：Stream `forEach` 在单线程情况下效率通常低于传统 `for` 循环和 `for-each` 循环，因为它涉及到更多的函数调用和中间操作。然而，Stream API 支持并行处理，这在处理大数据集时可能带来性能优势。
   - **使用场景**：适用于更加函数式的编程风格，以及需要链式操作（如过滤、映射、排序等）的场景。当数据集非常大或者需要并行处理以提高性能时，使用并行 Stream (`parallelStream().forEach(...)`) 是一个好选择。



# JVM

## jvm内存模型

1. **堆（Heap）**：
   - JVM 中最大的内存区域。
   - 存储所有 Java 类实例和数组。
   - 堆内存在 JVM 启动时创建，是垃圾收集器管理的主要区域。
2. **方法区（Method Area）**：
   - 存储已被虚拟机加载的类信息、常量、静态变量等数据。
   - 也称为“永久代”（Permanent Generation），在 Java 8 中被元空间（Metaspace）所替代。
3. **栈（Stack）**：
   - 存储局部变量和部分方法执行过程中的信息。
   - 每个线程有自己的栈，随着方法调用而动态扩展和收缩。
4. **程序计数器（Program Counter）**：
   - 当前线程所执行的字节码的行号指示器。
   - 每个线程都有自己的程序计数器。
5. **本地方法栈（Native Method Stack）**：
   - 为 JVM 使用的 Native 方法服务。
   - 与 Java 栈类似，但服务于 Native 方法调用。



## 垃圾回收（GC）

JVM（Java 虚拟机）的垃圾回收（GC）是自动管理内存的过程。它的主要目的是识别并丢弃那些不再被应用程序使用的对象，以释放并重用内存。以下是 JVM 垃圾回收的关键概念：

1. **垃圾回收根**：
   - GC 从所谓的“根”（如线程栈和静态字段）开始寻找，这些根是活动的引用。
2. **可达性分析**：
   - 从根集开始，GC 进行可达性分析，识别出所有从根集可达的对象。无法从任何根到达的对象被认为是垃圾。
3. **标记-清除算法**：
   - 最基本的垃圾回收算法。它分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，然后统一清除这些对象。
4. **复制算法**：
   - 主要用在新生代。内存分为两块，每次只使用其中一块。当这一块的内存用完时，将还活着的对象复制到另一块内存上，然后清理掉这一块内存上的所有对象。
5. **标记-整理算法**：
   - 用于老年代的一种方法。标记过程与标记-清除算法相同，但后续步骤是将所有存活的对象压缩到内存的一端，然后清理掉边界以外的内存。
6. **分代收集理论**：
   - JVM 的堆分为新生代和老年代。新生代中对象生命周期短，老年代中对象生命周期长。根据这个特性，使用不同的收集算法来提高垃圾回收的效率。
7. **垃圾回收器**：
   - 不同的 JVM 实现提供了不同的垃圾回收器，如 Serial、Parallel、CMS（Concurrent Mark-Sweep）、G1 等。每种回收器都有自己的特点，适用于不同类型的应用。



## JVM内存管理：新生代与老年代

在 JVM（Java 虚拟机）中，堆内存被分为几个区域以优化垃场的回收，其中最重要的区域是新生代（Young Generation）和老年代（Old Generation）。以下是它们的详细说明：

1. **新生代（Young Generation）**：
   - 新生代是堆内存的一个区域，用于存储新创建的对象。
   - 大多数情况下，新创建的对象首先被分配到新生代。
   - 新生代通常被进一步分为三个部分：一个 Eden 空间和两个幸存者空间（Survivor Spaces，通常称为 S0 和 S1）。
   - 新生代的特点是它经常进行垃圾回收，也称为 Minor GC。由于大多数新创建的对象很快就变得不可达（例如，局部变量），因此 Minor GC 通常很快且频繁地执行。
2. **老年代（Old Generation）**：
   - 老年代用于存储生命周期较长的 Java 对象。
   - 当对象在新生代中存活了足够长的时间（经过了多次 Minor GC）后，就会被晋升到老年代。
   - 老年代的大小通常远大于新生代，且其垃圾回收频率较低，但每次回收的时间比新生代要长。在老年代进行的垃圾回收称为 Major GC 或 Full GC。
3. **永久代/元空间（PermGen/Metaspace）**：
   - 在较早版本的 JVM 中，还有一个称为永久代（PermGen）的区域，用于存储类的元数据、方法对象等。
   - 从 Java 8 开始，永久代被移除，取而代之的是元空间（Metaspace）。元空间不在虚拟机内存中，而是使用本地内存。

这种内存区域的划分是为了优化垃圾回收效率。由于不同区域的对象生命周期不同，JVM 可以采用不同的策略来管理这些区域，从而提高整体的内存管理效率。



# spring boot

## Bean注册过程

1. **资源定位**：首先，Spring 通过配置文件或注解找到 Bean 的定义。
2. **载入 Bean 定义**：通过读取配置文件或注解，Spring 解析并将 Bean 定义加载到容器中。
3. **注册 Bean**：解析后的 Bean 定义被注册到 Spring 容器内。(解析一个注册一个)
4. **依赖注入**：容器分析 Bean 间的依赖关系，并完成相应的依赖注入。
5. **初始化**：创建 Bean 实例，并执行任何初始化逻辑。
6. **后处理**：应用如 AOP 的额外处理。



## Bean相关的注解

1. `@Bean`

- 用于在 Spring 管理的类中声明一个 Bean。
- 可以用于任何 Spring 管理的组件，但通常推荐在 `@Configuration` 类中使用。
- 定义方法返回的对象将作为一个 Bean 被 Spring 容器管理。

2. `@Configuration`

- 用于定义配置类，这些类可以包含一个或多个 `@Bean` 注解的方法。
- 被 `@Configuration` 注解的类本身也会作为一个 Bean 被注册到 Spring 容器中。
- `@Configuration` 类中的 `@Bean` 方法被特殊处理，以确保多次调用返回同一个实例。

3. `@Component`

- 基础注解，用于声明一个组件（Bean）。
- 用于那些不易归类为服务（`@Service`）或存储库（`@Repository`）的 Bean。
- `@Repository`、`@Service` 和 `@Controller` 都是这个注解的特化形式。

4. `@Service`

- 用于标注服务层组件。
- 用于业务逻辑层（Service Layer），表明类是业务逻辑相关的 Bean。

5. `@Repository`

- 用于标注数据访问层组件。
- 用于数据库访问操作，表明类是数据访问对象（DAO）。

6. `@Controller`

- 用于标注控制层组件。
- 用于 Web 应用的 MVC 模式，处理 HTTP 请求。

7. `@RestController`

- 结合了 `@Controller` 和 `@ResponseBody` 的功能。
- 用于创建 RESTful Web 服务，处理 HTTP 请求并以 JSON 或 XML 形式返回数据。



## @Service、@Repository、@Controller的区别

1. **@Service**：
   - 标注在服务层（业务逻辑层）的类上。
   - 主要用于标识业务逻辑服务组件。
   - Spring 框架可以对其进行一些特定的业务逻辑层面的处理，但在大多数情况下，`@Service` 注解仅作为一种标识，无额外的技术影响。
2. **@Repository**：
   - 标注在数据访问层（DAO）的类上。
   - 主要用于标识数据访问组件。
   - Spring 通过 `@Repository` 注解可以提供数据访问相关的异常转换功能。它可以将数据库异常转换为 Spring 的数据访问异常。
3. **@Controller**：
   - 标注在表现层（如 Web 控制器）的类上。
   - 主要用于标识处理 HTTP 请求的控制器组件。
   - `@Controller` 注解的类通常会配合 `@RequestMapping` 或其他相关注解来处理 HTTP 请求和返回相应的视图或数据。



## AOP

1. **AOP 概念**：AOP 是一种编程范式，用于将跨多个模块的关注点（如日志、安全、事务等）分离出来，以提高代码的模块化。
2. **切面（Aspect）**：切面是 AOP 的核心，它将横切关注点封装成独立的模块。一个切面可以定义多个通知（Advice）和切点（Pointcut）。
3. **通知（Advice）**：通知定义了切面要完成的工作以及何时执行这些工作。常见的通知类型有：前置（Before）、后置（After）、返回后（After-returning）、抛出异常后（After-throwing）和环绕（Around）。
4. **切点（Pointcut）**：切点定义了通知应用的位置，即哪些方法或类会触发切面的执行。
5. **织入（Weaving）**：将切面应用到目标对象并创建代理对象的过程称为织入。这可以在编译时（编译时织入）、类加载时（加载时织入）或运行时（运行时织入，Spring 使用这种方式）进行。
6. **代理（Proxy）**：在 Spring AOP 中，AOP 实现通常通过动态代理完成。这意味着为目标对象动态地创建一个代理，代理会拦截对目标方法的调用，并根据切面的定义在调用前后执行相关逻辑。



## class加载过程

1. **加载（Loading）**：
   - 在这个阶段，JVM 通过类加载器（ClassLoader）读取二进制数据（通常是 `.class` 文件）并将其转换为一个 `java.lang.Class` 对象。这个过程涉及到查找字节码，并从文件系统、网络或其他源加载字节码。
2. **链接（Linking）**：
   - **验证（Verification）**：确保加载的类符合 JVM 规范，没有安全问题。
   - **准备（Preparation）**：为类变量分配内存，并设置默认初始值。
   - **解析（Resolution）**：将类、接口、字段和方法的符号引用替换为直接引用。
3. **初始化（Initialization）**：
   - 在这个阶段，JVM 执行类构造器 `<clinit>()` 方法的代码。这包括静态变量的初始化和静态代码块的执行。
4. **使用（Using）**：
   - 类实例可以在程序中被使用，涉及到创建类的实例、调用类的方法、使用类的变量等。
5. **卸载（Unloading）**：
   - 类卸载是由 JVM 的垃圾回收器处理的。当一个类的 ClassLoader 和该类的所有实例都不再被引用时，JVM 就会卸载这个类。



## spring boot自动装配过程

1. **启动类上的注解**：Spring Boot 应用的入口类通常标有 `@SpringBootApplication` 注解，这个注解是一个方便的注解，结合了 `@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan`。
2. **启用自动配置**：`@EnableAutoConfiguration` 注解是自动配置的关键，它告诉 Spring Boot 开始查看添加到类路径中的 jar，基于这些 jar 提供的类和配置来配置应用程序。
3. **读取 `spring.factories`**：Spring Boot 会加载类路径上所有 `META-INF/spring.factories` 配置文件，这些文件列出了所有可用的自动配置类。
4. **条件评估**：每个自动配置类可以使用条件注解（如 `@ConditionalOnClass`、`@ConditionalOnBean`），这些注解确保只在满足特定条件时才启用自动配置。Spring Boot 会评估这些条件，并决定是否应用每个自动配置类。
5. **Bean 的创建和注册**：满足条件的自动配置类将被处理，它们内部定义的 Beans 会根据条件创建并注册到 Spring 容器中。这包括对一些常用库的自动配置，如数据库连接、消息服务、Web MVC 设置等。
6. **属性绑定**：Spring Boot 会使用 `application.properties` 或 `application.yml` 文件中的属性来覆盖自动配置提供的默认值。
7. **覆盖和自定义**：如果需要，开发者可以自定义额外的配置来覆盖自动配置提供的 Bean，或者通过创建自己的配置类来扩展自动装配。
8. **应用准备就绪**：完成上述步骤后，应用配置就绪，可以开始接受服务请求或执行业务逻辑。



## spring boot事物传播级别

Spring Framework 提供了多种事务传播行为，这些行为定义了事务方法是如何在事务上下文中执行的。在 Spring Boot 中，这些传播级别可以通过 `@Transactional` 注解的 `propagation` 属性来设置。以下是常用的事务传播级别：

1. **REQUIRED（默认）**：
   - 如果当前存在事务，那么方法将在该事务中运行；否则，将创建一个新事务。
2. **SUPPORTS**：
   - 如果当前存在事务，方法将在该事务中运行；如果当前没有事务，那么方法将在非事务的环境中执行。
3. **MANDATORY**：
   - 如果当前存在事务，方法将在该事务中运行；如果没有事务，则抛出异常。
4. **REQUIRES_NEW**：
   - 总是创建一个新事务，如果当前存在事务，则暂停当前事务。
5. **NOT_SUPPORTED**：
   - 总是非事务性地执行，并暂停任何现有事务。
6. **NEVER**：
   - 总是非事务性地执行，如果存在一个活动事务，则抛出异常。
7. **NESTED**：
   - 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则其行为与 `REQUIRED` 一样。

这些传播行为允许你精细地控制事务的边界和方式，非常适合处理复杂的业务场景。正确选择合适的传播级别可以帮助避免一些常见的问题，比如脏读、不可重复读、幻读以及长时间占用数据库资源等。



# 分布式、微服务

## 分布式事物

1. **两阶段提交（2PC, Two-Phase Commit）**：
   - 这是一种经典的分布式事务协议。它分为两个阶段：准备阶段和提交/回滚阶段。尽管两阶段提交可以保证事务的原子性和一致性，但它会锁定参与事务的所有资源，直到事务完成，这可能导致性能问题和资源瓶颈。
2. **三阶段提交（3PC, Three-Phase Commit）**：
   - 三阶段提交是对两阶段提交的改进，增加了一个预提交阶段，以减少资源锁定的时间。它更复杂，但比两阶段提交更可靠和高效。
3. **TCC（Try-Confirm-Cancel）**：
   - TCC 是一种补偿性事务模型，分为三个阶段：尝试（Try）、确认（Confirm）和取消（Cancel）。每个阶段都有相应的业务逻辑。如果在确认阶段之前出现错误，系统将执行取消操作来回滚之前的操作。
4. **本地消息表**：
   - 这种方案结合了数据库和消息队列。应用程序在执行业务操作的同时，将事件写入本地数据库的消息表中。然后，一个独立的进程或服务负责将这些事件发布到消息队列中，以触发后续的操作。
5. **Saga 模式**：
   - Saga 模式将长运行的事务分解为一系列更小的、局部的事务。每个局部事务提交后，Saga 会发布事件来触发下一个事务。如果某个事务失败，Saga 将执行一系列补偿事务来回滚之前的操作。
6. **分布式事务框架**：
   - 如 Seata、XA 事务等。这些框架提供了对分布式事务的支持，包括资源锁定、事务协调等功能。它们旨在简化分布式事务的处理，但可能会增加系统的复杂性。

## Seata 的 AT 模式

Seata AT 模式是一种自动化的分布式事务解决方案，用于简化微服务架构中事务的处理。它的核心特点和工作机制如下：

1. **自动化分布式事务管理**：
   - AT 模式通过代理数据源和 JDBC 层，无需修改业务代码，即可实现分布式事务的自动管理。
2. **两阶段提交**：
   - 第一阶段（准备阶段）：各个微服务执行本地事务，记录数据变更的前后镜像，但不提交事务。
   - 第二阶段（提交/回滚阶段）：Seata 服务器根据各服务的执行结果决定是提交还是回滚全局事务。
3. **数据一致性保障**：
   - 通过两阶段提交机制，确保所有参与的微服务要么全部成功提交事务，要么全部回滚，从而维持全局数据的一致性。
4. **优化资源锁定**：
   - 相比传统的 XA 协议，AT 模式减少了锁定资源的时间，提高了性能。
5. **故障恢复机制**：
   - 如果事务失败或系统异常，Seata 通过记录的数据镜像自动回滚变更，确保数据的一致性。

Seata 的 AT 模式是处理微服务环境中分布式事务的有效方法，它平衡了性能和一致性，为微服务应用提供了强大的事务管理能力。

# MySQL

## MySQL事物隔离级别

1. **读未提交（Read Uncommitted）**：
   - 这是最低的隔离级别，在这个级别下，事务可以读取到其他未提交事务的更改。这意味着可能会出现“脏读”（Dirty Reads），即读取到其他事务未提交的数据。
2. **读已提交（Read Committed）**：
   - 这个级别保证了一个事务不会读取到其他事务的未提交数据，避免了脏读。但是，它允许不可重复读，即在同一个事务内，连续两次读取同一数据可能会得到不同的结果，因为其他事务可能在这两次读取之间提交了更新。
3. **可重复读（Repeatable Read）**：
   - 这是 MySQL 默认的隔离级别。在这个级别下，保证了在同一事务内多次读取同一数据的结果是一致的，即避免了不可重复读。但在某些情况下，可能会遇到幻读，即当事务读取某个范围的记录时，如果另一个事务插入了新的记录，那么在随后的查询中，第一个事务可能会“看到”新的记录。
4. **串行化（Serializable）**：
   - 这是最高的隔离级别。它通过强制事务串行执行，完全避免了脏读、不可重复读和幻读问题。但这种级别的代价是可能导致大量的超时和锁争用问题。



## MySQL锁

1. **表锁（Table Locks）**：
   - 表锁是 MySQL 中最基本的锁策略。它会锁定整个表。这种锁的开销最小，但它的并发性最差，因为它会阻止其他用户对该表执行写操作。
2. **行锁（Row Locks）**：
   - 行锁是最细粒度的锁，仅锁定被访问的数据行。InnoDB 存储引擎支持行锁。行锁可以最大程度地支持并发处理，但管理行锁的开销也最大。
3. **页面锁（Page Locks）**：
   - 页面锁是介于表锁和行锁之间的一种锁。它锁定内存或磁盘上的数据页。这种锁比表锁的并发性高，但比行锁的开销小。MyISAM 存储引擎中不支持页面锁。
4. **意向锁（Intention Locks）**：
   - 意向锁是 InnoDB 用于表明某个事务打算对表中的行进行哪种类型的锁定（共享或排他）。这种锁是表级的。
5. **共享锁（Shared Locks）**：
   - 共享锁允许一个事务读取一行数据，同时其他事务也可以读取这行数据，但任何事务都不能修改它，直到共享锁被释放。
6. **排他锁（Exclusive Locks）**：
   - 排他锁允许事务对一行数据进行读取和写入操作，并阻止其他事务对该行数据进行读取和写入操作。
7. **间隙锁（Gap Locks）**：
   - 间隙锁是 InnoDB 特有的，用于锁定一个范围，但不包括记录本身。这主要用于事务隔离级别为可重复读（Repeatable Read）时，防止幻读现象。
8. **临键锁（Next-Key Locks）**：
   - 临键锁是 InnoDB 特有的，它是行锁和间隙锁的组合。它锁定一个范围，并包括范围内的行，防止其他事务在该范围内插入新行。



## MySQL索引

**索引的基本概念**：

- 索引是数据库表中一个或多个列的值存储在一个特定的物理结构中。索引的主要目的是加速查询操作，尽管它们也可以用于确保数据的唯一性或完整性。

1. **B-Tree 索引**：
   - 这是最常见的索引类型，用于大多数 MySQL 索引。B-Tree 索引适用于全键值、键值范围或键前缀查找。在 B-Tree 索引中，数据存储在树形结构中，以便快速读写。
2. **哈希索引**：
   - 哈希索引基于哈希表实现，只有精确匹配索引中所有列的查询才能使用哈希索引。哈希索引非常快，但它们不支持部分列匹配、范围查询或排序操作。
3. **全文索引**：
   - 全文索引专门用于全文搜索。在 MySQL 中，InnoDB 和 MyISAM 存储引擎支持全文索引。它们允许你对文本内容进行高效搜索。
4. **空间索引**：
   - 用于空间数据类型，如地理空间信息。这类索引用于高效解决地理空间数据的查询。
5. **复合索引**：
   - 复合索引是指在表的多个列上创建的索引。它们对于那些涉及多列的查询非常有用。在创建复合索引时，列的顺序很重要。
6. **主键索引**：
   - 在 MySQL 中，表的主键自动成为一个唯一索引。主键用于唯一标识表中的每一行，并且要求主键列中的值必须唯一。
7. **唯一索引**：
   - 唯一索引不仅加快查询速度，还保证索引列的每行数据的唯一性。与主键索引类似，但一个表可以有多个唯一索引。
8. **外键索引**：
   - 在使用 InnoDB 存储引擎时，MySQL 会自动在外键上创建索引（如果尚未存在）。外键索引用于加速表之间的关联操作。



# 中间件

## docker和k8s的区别

- Docker 是一个容器化工具，主要用来把应用打包进容器，让它们在任何环境中都能以相同的方式运行。它主要处理单个容器的创建、运行和管理。

- Kubernetes，另一方面，是一个容器编排工具。它用来管理和调度多个容器（可能是用 Docker 创建的）在一个集群中的运行。Kubernetes 能做到自动化部署、扩展应用和保持应用的稳定运行。

- 所以基本上，Docker 更多关注于单个容器层面，而 Kubernetes 则是在更高层面上管理这些容器，特别是在大规模和分布式系统中。



1. **基本概念和作用**：
   - **Docker**：Docker 是一个容器化平台，它允许开发者将应用及其依赖打包到一个轻量级、可移植的容器中。容器在运行时在 Docker 引擎上相互隔离，共享同一操作系统内核。Docker 主要用于创建和管理单个容器。
   - **Kubernetes**：Kubernetes 是一个容器编排系统，用于自动化容器的部署、扩展和管理。它设计用来在集群环境中运行和协调多个容器化应用或服务。
2. **功能和范围**：
   - **Docker**：提供了容器的生命周期管理，包括容器的构建、运行、停止和删除。Docker 通过 Dockerfile 简化了容器创建的过程。
   - **Kubernetes**：提供了更广泛的系统级功能，如集群管理、服务发现、负载均衡、自动扩展、滚动更新和自愈能力。
3. **使用场景**：
   - **Docker**：适用于开发阶段的应用容器化、简单的应用部署和单机上的容器管理。
   - **Kubernetes**：适用于生产环境中的大规模容器管理，特别是当需要高可用性、扩展性和复杂的服务协调时。
4. **架构**：
   - **Docker**：采用客户端-服务器架构。Docker 客户端与 Docker 守护进程（服务器）交互，守护进程负责构建、运行和分发容器。
   - **Kubernetes**：采用主从架构。Kubernetes 集群由一个或多个主节点（负责集群管理和调度）和多个工作节点（运行容器化应用）组成。
5. **可伸缩性和高可用性**：
   - **Docker**：单独使用 Docker 时，并不直接提供多节点集群的高可用性和可伸缩性支持。
   - **Kubernetes**：天然支持多节点集群，能够自动管理和扩展应用，提供故障转移和负载均衡能力。











